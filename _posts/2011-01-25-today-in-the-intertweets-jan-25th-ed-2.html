---
layout: legacy-post
title: Today in the Intertweets (Jan 25th Ed)
wordpress_id: 1476
wordpress_url: http://disclojure.org/?p=1476
date: 2011-01-25 22:47:27.000000000 -08:00
---
Note: This post covers all events since last Thursday (the 20th). I had technical difficulties (Comcast, I am looking at you!) all weekend until today. In any case, lots of cool stuff in this post :)
<ul>
	<li>live-processing. a #processing clone with livecoding capabilities. build on #clojure (<a href="http://automata.cc/live-processing">here</a>, via @vilsonvieira) -- <a href="http://processing.org/">Processing</a> is a programming language for image generation and interactive applications. This project makes it possible to program processing live, at the REPL, in clojure :)</li>
	<li>Just uploaded a guided example on building clojure apps for android using #maven &amp; #emacs. #clojure (<a href="https://github.com/hsaliak/android-clojure-flashlight-example">here</a>, via @hsaliak) -- The README in the project contains very detailed instructions to get this project working on your fancy phone (that is not an iPhone) You have no excuse now.</li>
	<li>A clojure swank server on android devices using<a href="https://github.com/exterm/clojure/blob/android_runtime_bytecode/src/jvm/clojure/lang/Android.java"> this hack</a> (<a href="https://github.com/exterm/swank-android-builder">here</a>, via @alandipert) -- <a href="https://github.com/exterm/swank-android-builder">swank-android-builder</a> is a script that will download all the components and build them into what is the android-swank application.</li>
	<li>Cleaning Old Definitions from the REPL : shred-user (<a href="http://www.learningclojure.com/2011/01/cleaning-old-definitions-from-repl.html?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+clojure+%28Planet+Clojure%29&amp;utm_content=Twitter">here</a>, via @planetclojure) -- This is a tremendously useful hack to clean out your 'user' namespace (or any other for that matter) of any function definitions or other root bindings that you might have created. By the way, this blog is full of good stuff!</li>
	<li>Scheme interpreter in clojure:      昨天晚上用clojure搞了个scheme解释器，基本上是sicp里的解释器的clojure翻译版本，可能唯一值的一提的是对transient集合的使用... (<a href="http://www.blogjava.net/killme2008/archive/2011/01/24/343423.html?utm_source=twitterfeed&amp;utm_medium=twitter">here</a>, via @rainmanzhu) -- A scheme interpreter in clojure. Guess what is missing? ... yeah, tail call optimization. I wonder why? For what I can gather, this is based on the interpreter described in <a href="http://mitpress.mit.edu/sicp/">SICP</a>.</li>
	<li>An Error Monad in Clojure (<a href="http://brehaut.net/blog/2011/error_monads">here</a>, via @hnfirehose) -- Make sure you read the words in this tweet in the right order in order to avoid Freudian slips. To be clear, it doesn't say "Monads are an error in Clojure". This article shows what monads can be used for; in this case, an if-let of sorts that can handle many clauses and that will skip the evaluation of the body if any of the clauses fails.</li>
	<li>A LinkedBlockingQueue Transport for Conduit (or one way of sucking async data into a distributed processing system) -- <a href="http://intensivesystems.net/tutorials/stream_proc.html">Conduit</a> is a stream processing library for Clojure. From the author of this post: "... but all I really understand is that arrows are like monads, but even even scarier." Excuse me, scarier than monads?!</li>
	<li>New clojure conj video up, @chrishouser: "Finger Trees: Custom Persistent Collections" (<a href="http://clojure.blip.tv/file/4614554/">here</a>, via @clojure_conj) -- A <a href="http://en.wikipedia.org/wiki/Finger_tree">finger tree</a> is an interesting purely functional data structure that can be used to create other more common data structures in a very efficient way. Used in Haskell and OCaml, soon they'll be available in clojure.</li>
</ul>
